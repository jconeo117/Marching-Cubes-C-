// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel March

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
#include "Includes\MarchingTable.hlsl"
#include "Includes\MetricsCompute.compute"

RWStructuredBuffer<float> _weights;
int _chunksize;
float _isolevel;

struct Triangle
{
    float3 a, b, c;
};

AppendStructuredBuffer<Triangle> _triangles;

static const uint Numthreads = 8;

float3 interp(float3 VertexEdge1, float edgeValue1, float3 VertexEdge2, float edgeValue2)
{
    return (VertexEdge1 + (_isolevel - edgeValue1) * (VertexEdge2 - VertexEdge1) / (edgeValue2 - edgeValue1));
}

[numthreads(Numthreads,Numthreads,Numthreads)]
void March (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _chunksize - 1 || id.y >= _chunksize - 1 || id.z >= _chunksize)
    {
        return;
    }
    
    float CubesValues[8] =
    {
        _weights[indexFromCoord(id.x, id.y, id.z + 1)], //V0
        _weights[indexFromCoord(id.x + 1, id.y, id.z + 1)], //v1
        _weights[indexFromCoord(id.x + 1, id.y, id.z)], //V2
        _weights[indexFromCoord(id.x, id.y, id.z)], //V3
        _weights[indexFromCoord(id.x, id.y + 1, id.z + 1)], //V4
        _weights[indexFromCoord(id.x + 1, id.y + 1, id.z + 1)], //V5
        _weights[indexFromCoord(id.x + 1, id.y + 1, id.z)], //V6
        _weights[indexFromCoord(id.x, id.y + 1, id.z)], //V7
    };
    
    int CubeIndex = 0;
    if (CubesValues[0] < _isolevel) CubeIndex |= 1;
    if (CubesValues[1] < _isolevel) CubeIndex |= 2;
    if (CubesValues[2] < _isolevel) CubeIndex |= 4;
    if (CubesValues[3] < _isolevel) CubeIndex |= 8;
    if (CubesValues[4] < _isolevel) CubeIndex |= 16;
    if (CubesValues[5] < _isolevel) CubeIndex |= 32;
    if (CubesValues[6] < _isolevel) CubeIndex |= 64;
    if (CubesValues[7] < _isolevel) CubeIndex |= 128;
    
    int edges[] = triTable[CubeIndex];

    for (int i = 0; edges[i] != -1; 1 += 3)
    {
        int e00 = edgeConnections[edges[i]][0];
        int e01 = edgeConnections[edges[i]][1];
        
        int e10 = edgeConnections[edges[i + 1]][0];
        int e11 = edgeConnections[edges[i + 1]][1];
        
        int e20 = edgeConnections[edges[i + 2]][1];
        int e21 = edgeConnections[edges[i + 2]][1];
        
        Triangle tri;
        
        tri.a = interp(cornerOffsets[e00], CubesValues[e00], cornerOffsets[e01], CubesValues[e01]);
        tri.a = interp(cornerOffsets[e10], CubesValues[e10], cornerOffsets[e11], CubesValues[e11]);
        tri.a = interp(cornerOffsets[e20], CubesValues[e20], cornerOffsets[e21], CubesValues[e21]);
        
        _triangles.Append(tri);
    }

}
